Bom, pessoal, então, baseado nestas fitness functions, vamos tentar entender um pouco mais claramente como isso acaba se comportando. Vamos lá. Toda vez que a gente fala sobre fitness function, no final das contas a gente está falando em uma forma de medir a efetividade, a performance e os fatores relevantes, de acordo com a arquitetura de um software. É isso que você tem que pensar na hora que a gente fala em fitness function. Ou seja, a gente está falando em medir, verificar o quanto isso é efetivo e como o meu software está performando. E essa performance não é performance necessariamente de velocidade, é uma performance de como ele consegue entregar aquilo que ele foi feito para fazer.

Quais são fatores importantes, inclusive, para esse software conseguir fazer diferença? Outro ponto importante  sobre fitness functions é o seguinte: elas são definidas baseadas em diversos critérios, incluindo nesse caso performance, modularização, mantenabilidade, escalabilidade e segurança. Então, toda vez que você vai pensar em uma fitness function, você pensa: “Quais são os critérios que fazem muito sentido para mim? Para eu conseguir medir o quão o meu software… e como o meu software está evoluindo?” O que faz sentido? Se é um software que precisa de muita performance, vamos medir como está o nível de complexidade no meu código; vamos ver como está a complexidade ciclomática no meu código. “Ah, o meu código tem um monte de componente’’, vamos medir como está a relação entre os componentes desse software e o quão complexo aquilo está ficando. Se eu tenho um monte de classe, uma classe a ponto para outra, se eu estou ficando com muita herança, se eu estou trabalhando com diversas coisas no meu software, eu consigo começar a medir o nível de complexidade. Há pessoas que, dependendo da forma como a empresa se organiza, tentam ao máximo evitar comentários no código. Então, se eu começar a medir a quantidade de comentários que eu tenho no meu software, baseado nesses comentários, eu começo a pensar, toda vez que tem um comentário, eu tenho uma red flag. Logo, baseado na quantidade de comentários, eu posso conseguir colocar um threshold ali, que eu tenho que tomar cuidado com o meu software. Se eu tiver um software que é só comentário, mas entenda, quando eu estou falando de comentário, comentário é uma coisa, documentação é outra. Por exemplo, a linguagem Go. Como você documenta essa linguagem? Através de comentários, entendeu? Mas aquele comentário tem o objetivo de gerar documentação. Agora, a gente tem comentários, por exemplo, que vai falar o seguinte: ‘olha, esse pedaço eu estou fazendo assim porque ele vai calcular a taxa de juros, ele vai dividir, e isso é baseado de acordo com aquela tabela que foi passada naquele dia para mim”. Esse tipo de comentário, eventualmente, pode ser um malefício para o software, quer dizer que o meu software não está expressando aquilo que ele deve fazer. Isso é uma polêmica, principalmente por conta do livro do Clean Code do Uncle Bob, onde fala que não deve ter comentários e etc.

Obviamente, eu não trabalho de uma forma “ferro e fogo”, muito código meu, que em alguns pontos  eu acho complexo, eu coloco comentário, inclusive. Mas, novamente, será que eu estou colocando o comentário porque é complexo ou o meu código ficou complexo por isso que eu tenho que ter comentário? Cada empresa tem uma maneira, de forma geral, de medir a complexidade que o software está. Ou é em relação entre classes, em relação à herança, a quantidade de linhas dentro de um arquivo, a quantidade de linhas no tamanho do meu software, ou, por exemplo, tem muita gente que começa a medir o software da forma seguinte: toda vez que o domínio do meu software começa a mudar muito, significa que eu vou ter mais instabilidade no meu software. Então, e se a gente medir a quantidade de mudanças que a gente tem no core do software? Se a gente tem muita mudança aqui, quer dizer, por exemplo, que eu tenho algum problema, ou eu posso fazer medições em relação à parte de coesão. Toda vez que eu mexo num arquivo, eu tenho que mexer em outro. Toda vez que eu mexo numa parte, eu tenho que mexer em outra. Isso quer dizer que provavelmente está faltando coesão no meu software. Toda vez que você tem que mudar alguma coisa, você tem que sair mudando em outros pontos. Isso quer dizer que pode ter um “cheiro” ruim. A gente tem um bad smell  no seu software, então você pode querer medir isso. Depende muito de cada tipo de software, se é um software que precisa de muita performance, obviamente alguns desses pontos você vai querer medir.

Agora que são softwares que precisam ou eles têm outras características, às vezes, isso é irrelevante para você. Então olha como é importante você ter esse tipo de visão. E você só vai ter esse tipo de visão se conseguir medir. Daqui a pouquinho a gente já vai falar para você como a gente media, eu vou dar um exemplo claro aqui para vocês. Outro ponto importante é, a fitness function vai acompanhar o seu software e a sua evolução. Se é para acompanhar, significa que você vai ter dados, e não somente dados, você vai ter dados conforme o tempo vai passar. Dados baseado no tempo, e conforme os tempos passam você vai ter uma taxa, e quanto maior essa taxa, melhor o seu software está, quanto menor essa taxa, mais se degradando o seu software vai estar. O grande ponto é que partes desses atributos, que a gente acabou olhando no nosso software, simplesmente têm pontos que têm mais peso. O comentário pode ser algo crítico, então, eu não vou dar um peso tão grande caso eu tenha muita complexidade na parte… você começa a pegar, fazer verificação de algoritmos e o nível de complexidade dos seus algoritmos, você pode dar mais. Ah, o response time é muito importante para mim, então, esse tem um peso maior do que o comentário. Ah, o débito técnico é tão importante quanto performance para mim, para eu conseguir controlar esses tipos de coisa. O tempo de recuperação, quando o meu software cai do ar. Então, esses tipos de pontos são importantes porque são métricas que vão verificar holisticamente como o seu software está. E o que acontece? Uma vez que você consegue verificar os aspectos mais críticos e os menos críticos colocados no seu software, você vai conseguir ter essa métrica. Agora o ponto é o seguinte, como assim são os pontos críticos? O grande ponto é que muita gente, quando começa a trabalhar com essas fitness functions, quer medir tudo. E, às vezes, o cara vai querer medir todos os endpoints e ver o response time. Será que é preciso realmente fazer isso? Por isso que a gente tem que pensar no nível de criticidade. Eu tenho 50 endpoints na minha aplicação, mas 80% dos endpoints das chamadas estão batendo nesses 20% desses endpoints. Eu vou medir somente esses 20, esses caras são os mais importantes. Esses caras podem gerar mais lentidão e mais impacto no meu software. Por isso que a gente precisa identificar os aspectos críticos do sistema.

Portanto, sobre pontos críticos, você não precisa ficar querendo medir o software inteiro, senão daqui a pouco a gente começa a cair novamente naquele efeito torre de marfim, ivory tower, onde o arquiteto está tão descolado da realidade; o software está com tanto débito técnico e ele está querendo ver aquele detalhe daquele endpoint que faz um ano que ninguém acessa, entendeu? Então, esses pontos são importantes. A grande questão dessas fitness functions é como eu consigo medir? “Wesley, você está falando muita teoria. Como a gente consegue ir para a prática e pensar nesses aspectos?” A gente vai fazer isso no nosso próximo vídeo. Vamos nessa!