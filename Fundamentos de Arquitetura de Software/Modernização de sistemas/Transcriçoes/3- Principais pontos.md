Mas vamos lá, quais são os principais pontos que a gente tem que ter na cabeça quando falamos sobre mudar um sistema? Vou tentar compartilhar com vocês um pouco da minha história, um pouco do que eu aprendi — muito mais do que só uma conversa de conteúdo que você consegue até buscar na internet. O que eu quero trazer para vocês é um pouco da minha experiência, para que vocês não gastem energia à toa. Talvez hoje isso não faça tanto sentido, mas eu vou compartilhar o que vi funcionando. Acho que podemos economizar tempo de vida e de entrega. O que aprendi em sete anos, vou tentar passar para vocês neste material, para que consigam ser mais eficientes no dia a dia ao fazer isso.

Então, sendo bem direto, pensem nas coisas que estou falando aqui. Não é só sobre tecnologia, é sobre tudo. Precisamos ter uma visão geral. Tecnologia é apenas um dos pontos. Vocês verão que vou abordar vários deles. Antes de pensar em termos de "temos um monólito, vamos quebrá-lo e levá-lo para a nuvem" — que é onde normalmente focamos, na execução — é muito importante definir os objetivos.

É como eu disse: imagine que, com o monólito anterior, eu quisesse migrá-lo para a AWS, utilizando Kotlin, deixando-o super desacoplado. Mas por quê? Quais são os objetivos que queremos atingir? Parece bobeira, mas se seus objetivos não estiverem muito claros, você vai falhar. Vai falhar porque não depende só de você e do que está na sua cabeça. Às vezes, achamos que modernizar um sistema por meio da tecnologia é o suficiente. Eu mesmo já fiz isso: transformei um sistema antigo em algo mais moderno e acabei tornando a manutenção mais difícil.

Deixe-me compartilhar uma experiência: “Teve uma vez que migrei de um monólito para microsserviços, mas em vez de uma abordagem de microsserviços, acabei indo para quase nanosserviços. O serviço ficou tão pequeno que, na hora de dar manutenção e entender as mensagens trocadas para fazer um troubleshooting, virou um pesadelo. Foi muito difícil e tivemos que repensar e mudar a arquitetura para algo mais gerenciável”. Então, é essencial definir os objetivos que você quer atingir e mapear quais stakeholders vão participar dessa transformação.

Se você está constantemente ouvindo dos stakeholders que não é para mudar nada, que preferem adicionar novas funcionalidades a sistemas já existentes, sua vida será um inferno. Isso só cria mais complexidade. Também é importante. E vocês vão ver que eu abrirei várias aspas aqui para contar pequenas histórias. 

Em um determinado momento da minha carreira que eu estava fazendo um projeto que era claro que era para a gente modernizar um sistema, saindo ele de uma plataforma COBOL, indo para um JAVA na AWS, e a gente começou a criar algumas mudanças para começar a fazer essa migração e no meio do caminho começou a vir tanto projeto, e tantas ideias diferentes que para fazermos na plataforma nova demoraria mais tempo porque a gente estava começando a construir e os stakeholders não tiveram paciência. Eles quiseram fazer isso mais rápido e acabaram pedindo para fazer de volta no COBOL. Então, ficamos com meia plataforma na distribuída em JAVA, e metade da plataforma no COBOL e com algumas peças para fazer uma conversa de uma coisa com a outra. Ou seja, trouxe apenas mais complexidade. Antes eu tinha uma plataforma monolítica em COBOL, e agora eu tinha uma plataforma monolítica, outra plataforma sendo replicada na distribuída e ainda tinha que fazer uma coisa falar com a outra. Morfologia de dados para baixo e para cima para conseguir fazer o sistema se conversar. Assim, ficamos bem mais caros durante algum tempo até a gente entender que não estávamos indo atrás do objetivo que tínhamos definido.  E que os stakeholders não estavam comprados com aquele objetivo.Então, entenda bem o objetivo e alinhe isso com os stakeholders. Se eles não estiverem comprometidos, o projeto não vai funcionar.

Outro ponto relevante: falamos muito de tecnologia, como "vamos usar Kotlin", "vamos usar Java", "vamos implementar com Micronaut", "vai ser com SQS, vai ser mensageria". Mas, antes de tudo, precisamos definir os contextos. É importante pensar nisso antes de mergulhar em aspectos técnicos. Por exemplo, eu vou ter um contexto de pagamento? Ou um contexto de criação de pessoas no sistema? Preciso separar pagamentos por cartão de crédito de pagamentos via Pix? Ainda há quem pague com boleto bancário, até carnê — esse é para os mais velhos. Mas vai existir diversos tipos de contexto, por isso faz sentido você pensar muito bem antes de sair fazendo para não acontecer como eu já mencionei de irmos para uma ideia de nanosserviço que vai gerar muito mais dificuldade. Ou pior do que isso, que é termos também com contextos cruzados. Depois da modernização, pode ficar difícil entender se uma parte é responsabilidade do seu time ou de uma outra squad. “Essa parte é do contexto de pagamento, ou por exemplo, eu quebrei para um contexto da data atual, antecipar parcelas seria do contexto de pagamento ou do contexto de calculadora?”. Pensa nos contextos de forma clara e não caia na armadilha de replicar a estrutura organizacional no sistema, porque essa estrutura muda, e o sistema precisa ser independente dessas mudanças.

Tente não replicar a estrutura da sua organização diretamente no seu time, pois a estrutura também muda, o que é muito importante. Cada vez mais, as estruturas, lideranças e equipes, mesmo quando buscamos times mais autocontidos e com menos mudanças, enfrentam alterações estratégicas no dia a dia, o que gera mudanças na organização. Tome cuidado para não desenhar seu sistema com base na estrutura da sua organização. Todos entendem que isso pode acontecer, mas devemos evitar essa armadilha ao máximo. Se o chefe muda, você muda, e outra pessoa também muda, quem vai conseguir entender o sistema? Pense no contexto pelo contexto. Faz sentido que o processo de recebimento esteja no mesmo contexto que o de contabilização? Se fizer, vamos juntar; se não fizer, vamos manter separados. E, caso sejam separados, mantenha suas fronteiras bem definidas.

Outro ponto importante é definir uma arquitetura-alvo. Onde queremos chegar? Como será o desenho futuro? Quais são os problemas que isso pode trazer? Toda arquitetura tem seus pontos fracos, e é importante estar consciente disso. Não existe bala de prata. Uma arquitetura totalmente orientada a eventos, por exemplo, pode ser mais complexa no dia a dia. Mas isso não significa que ela seja ruim, apenas que traz desafios próprios.

Define uma arquitetura de transição. Para mim, isso é o que ganha o jogo. Normalmente, desenhamos uma arquitetura por sermos da área de tecnologia, e adoramos fazer as coisas bonitas. Costumo dizer que quem gosta de TI quer, no fim do dia, ser aquele artesão que faz uma peça totalmente complexa que só ele entende, uma peça bonita para pendurar na parede. Então, a arquitetura-alvo normalmente será um pouco isso: aquilo que entendemos como o supra-sumo do nosso sistema. Mas vamos alcançar essa arquitetura-alvo em um mês? Não. E precisamos gerar algum valor até para acalmar os stakeholders, para mostrar valor, porque isso é um investimento. Você está investindo pesado na sua plataforma e quer ver se ela vai funcionar, até para confirmar se a arquitetura-alvo está no caminho certo, pois também podemos errar. A chance de erro é grande, já que estamos fazendo muitas coisas novas. Por isso, definir uma arquitetura de transição é muito importante. Precisamos dizer: "Até chegarmos à arquitetura-alvo, vamos conviver desse jeito com o que é novo e com o que é antigo. Vamos operar com as plataformas assim. Vamos aceitar esses riscos, inclusive pagar mais caro por ter que processar duas vezes." Teremos que discutir algumas questões sobre as arquiteturas de transição, e eu gosto de dividi-las. Por exemplo: em três meses, teremos essa arquitetura de transição; em seis meses, outra; em oito meses, uma terceira; e, daqui a um ano, chegamos na arquitetura-alvo. Isso é extremamente importante para fazer entregas e conseguir gerar valor mais rapidamente, além de dar ao time aquele gostinho de como as coisas estão mudando.

Aqui, acho uma coisa muito importante: no último projeto em que trabalhei, tínhamos uma consulta de saldo. Essa consulta demorava cerca de 14 segundos na arquitetura antiga. Quando começamos a mudar, eu defini uma arquitetura-alvo em conjunto com uma arquitetura de transição. A primeira coisa que entregamos foi essa consulta de saldo na arquitetura de transição, e o tempo de resposta caiu para uma média de 86 milissegundos, com o P99 na casa dos 100 milissegundos. Depois, otimizamos ainda mais, reduzindo o P99 para 86 milissegundos. Saímos de 14 segundos para 86 milissegundos. Isso já gerou uma percepção entre os stakeholders de que o que estávamos fazendo traria uma nova visão para o cliente. Sair de 14 segundos para 86 milissegundos é uma diferença enorme, trazendo muitos benefícios para o dia a dia. Se você não está acostumado a falar tanto sobre velocidade, vou pedir um favor: pegue seu celular, coloque 14 segundos no cronômetro e olhe para a tela. Você vai perceber como é irritante esperar tanto tempo para uma requisição retornar o saldo. Já tive momentos, em outros sistemas, em que as requisições demoravam esse tempo, mas ao reduzirmos para 86 milissegundos, ficou claro como a experiência do usuário melhora.

Outra coisa: use o stack como aliado, não como inimigo. Por que digo isso? Muitas pessoas ficam obcecadas em usar Micronaut, Quarkus, Kotlin, ou qualquer outra tecnologia. Calma. O stack precisa ser seu aliado. Se você tentar resolver tudo com o mesmo stack, vai dar errado. Haverá momentos em que Python será necessário, outros em que Java será a melhor escolha, e tudo bem. Às vezes, um banco de dados relacional faz sentido, outras vezes não. Não adianta querer usar algo só porque está na moda, exemplo: "Isso aqui é muito legal, todo mundo está usando, eu também quero." Isso pode gerar mais problemas. Pense no simples, não no complexo. As ideias de arquitetura e de sistemas devem sempre ser para resolver um problema, não para atender ao seu gosto pessoal.

Outro ponto importante, que discuto bastante com os times, é o seguinte: "Quero começar a usar Golang." Eu adoro Golang, até o Wesley também adora. Mas se eu precisar montar um time com 100 pessoas para codar em Golang, não é tão fácil encontrar gente no mercado. Preciso pensar nisso. Não é só sair codando uma nova plataforma inteira em Golang e depois ter que treinar 500 pessoas. Esse é um exemplo, e há vários outros que devemos considerar no dia a dia. Não vou falar de .NET Core, porque senão vai ter gente que não vai gostar. Não vou trazer esse assunto à mesa hoje. Acho que hoje não é dia de briga.