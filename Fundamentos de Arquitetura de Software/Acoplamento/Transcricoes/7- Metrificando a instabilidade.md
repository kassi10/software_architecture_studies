Bom, pessoal, seguinte, como eu consigo metrificar essa instabilidade? Porque até agora o que eu falei para vocês foi: mapeiem o sistema de vocês. Vejam a quantidade de chamadas que os seus componentes têm, quanto mais você está chamando, quanto mais um componente é chamado, você começa a pensar: “ok, eu fiz isso, mas como eu consigo saber realmente se o meu sistema está instável ou se ele tem uma chance maior de estar instável ou não?” Galera, grande parte do que eu estou pegando de referências, inclusive, do que eu acabei de passar para vocês, consta também no livro Clean Architecture, do Uncle Bob. Ele fala bastante sobre isso. E o que eu acho interessante é que a gente tem uma fórmula para você conseguir metrificar, inclusive, o nível de instabilidade que os seus componentes possam ter. “Como assim, Wesley” Olha só que interessante. Isso é uma fórmula. Você pega a instabilidade, é igual ao fan-out, ou seja, a parte eferente dividida pela parte aferente mais a eferente. “Como assim?”  baseado nessa fórmula, você vai ter um resultado entre 0 e 1 e quanto menor o valor, ou seja, quanto mais próximo de 0 o valor, isso define que o seu componente é mais estável. Quanto mais próximo de 1, quanto maior o valor, isso vai dizer que o seu componente é mais instável. (Tem que ajustar no nosso PowerPoint). Então, o que acontece com esse caso? Como a gente pode trabalhar dessa forma? Olha só que interessante. Eu peguei esse desenho, inclusive, do livro do Clean Architecture. Imagina que temos alguns componentes, isto é, componentes CA, CB, CC, CD e esses componentes têm algumas classes.  Você pode perceber que o componente CA tem a classe Q que depende da classe T. O componente A também tem a classe R , que depende da classe U; e o componente CB tem uma classe S que depende da classe U. Agora se você perceber, o nosso componente CC tem o quê? Um cara dependendo dele, dois caras dependendo dele, três caras dependendo dele. E ele mesmo depende de um cara, perfeito? Acredito que é bem simples de a gente conseguir ver isso. Olha só que interessante como ficaria aqui a nossa fórmula. Eu falaria que a instabilidade é o fan-out dividido pelo fan-in mais o fan-out. Então, o que acontece? Olha só, eu tenho o I de instabilidade é igual a 1, ou seja, o meu acoplamento eferente é 1, porque eu estou dependendo de um cara. Dividido por 3 porque tem 3 acoplamentos aferentes que acabam batendo em mim, no meu componente CC, mais o meu acoplamento eferente. Logo, fica 3 mais 1 que é igual a 1 quarto, que é igual a 0,25. Portanto, 0,25 é o grau de instabilidade que o meu sistema vai ter.

Então, essa é a ideia de como você pode metrificar. “Wesley, mas eu vou ter que ficar metrificando todos os meus componentes?” Não,. Mas sem dúvidas, componentes que você considera que são mais core da sua aplicação e que você queira ter um cuidado muito grande em manter esse cara por longo tempo, é interessante você aos poucos sempre ficar medindo o nível de instabilidade. Por exemplo, imagina se tem um componente super core e muita gente está utilizando ele, “ok”, ele é crítico, mas se esse componente sendo o core começar a depender de muitos outros componentes, o que significa? Que você vai ter provavelmente um componente core instável e um componente core instável vai gerar uma instabilidade muito maior para o restante do sistema.

Portanto, quando você tem essa visão, você começa a pensar em como vai modelar os seus componentes core da sua aplicação, para que você consiga fazer com que ele dependa diretamente… dependa menos diretamente de outros componentes, para que outros componentes possam depender dele e que esses componentes possam ter mais estabilidade. Essa é a pegada. No próximo vídeo, a gente vai falar também em como a gente consegue mitigar alguns pontos, quando a gente ainda está falando em acoplamento. Vamos lá!

