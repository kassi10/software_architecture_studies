Bom, pessoal, no nosso vídeo anterior a gente acabou falando bastante sobre sistemas monolíticos e eu também falei algumas regrinhas, vamos dizer assim, para que você não guarde estado na sua aplicação. Para que ela consiga escalar de forma mais fácil. Também falei sobre o 12 factor app e aqui é o site desse camarada aqui, que é https://12factor.net/pt_br/ . (Eu vou deixar anexado para vocês).

Esse cara aqui, esse documento, essa forma de trabalhar, entre aspas, revolucionou muito e direcionou muito grandes aplicações que precisam escalar por muito tempo e até hoje isso indiretamente ou diretamente é utilizado. Talvez hoje você já trabalhe dessa forma, porque você já foi, vamos dizer, doutrinado a trabalhar dessa forma desde quando você começou a programar, mas quem tem pelo menos uns 10, 15 anos de carreira e quando trabalhava de outras formas, onde a escala não era um problema tão grande, raramente seguia isso aqui. Isso aqui foi uma grande mudança, uma grande virada de chave para você conseguir escalar o software. Isso principalmente por quê? Porque quando o Heroku estava sendo criado, a ideia dele sempre foi trabalhar num formato de container já lá naquela época, mas esses containers, os Dynos do Heroku sempre eram criados, escalados e desescalados, então você tinha necessidade de precisar “matar” toda hora a aplicação e crescer a aplicação a todo momento e, para isso, você precisava seguir algumas guidelines para que você evitasse no final do dia manter estado. Então, olha só que interessante, numa era moderna é muito comum a gente entregar aplicações web ou SaaS, Software as a Service, então o 12 Factor App é uma metodologia para construir Software as a Service de aplicações que usem setups declarativos e automáticos para minimizar tempo e o custo para novos developers que entrem no projeto e que tem um contrato clean, um contrato limpo, por baixo dos panos, provendo uma máxima portabilidade nos ambientes. Isso aqui é um ponto importante também, porque na hora que a gente vai botar um software em produção, antes disso a gente pode botar esse software em desenvolvimento, em staging, em teste. Então, cada vez que você muda o ambiente você pode, inclusive, fazer com que o software comporte de forma diferente ou mesmo utilize um banco de dados diferente, utilize configurações diferentes e tudo mais. Então, quando a gente está falando disso, essa metodologia que foi criada nessa época é para conseguir minimizar esses tipos de problema, facilitar a portabilidade e também ficar mais fácil para que você consiga fazer o deploy das suas aplicações nas cloud platforms. Isso também vai te ajudar no processo de continuous deployment, ou seja, na parte de CD e vai te ajudar a escalar as aplicações, então, basicamente é isso que eles estão falando.

Agora, o grande ponto aqui é como fazer isso. E, nesse ponto, vem a ideia do 12-factor app, porque são 12 pontos que você tem que levar em consideração. Ou seja, quais são esses 12 pontos Codebase, ou seja, utilize um sistema de versionamento de código, um Git da vida, por exemplo, porque você controlando as versões, as revisões, você pode realizar diversos deploys. Dependências. As dependências têm que estar declaradas explicitamente isoladas para que todas as vezes que o seu software for subir, você consiga trabalhar com essas dependências. Normalmente, só para você tangibilizar um pouco mais, o seu composer.json, o seu package.json, o seu go-mod são locais onde você declara claramente as dependências, inclusive as versões que essas dependências utilizam por conta disso. Outra coisa que é muito utilizado, para você conseguir trocar de ambiente, trabalhe com configurações de forma declarativa para você conseguir trabalhar. Então, sabe aquele arquivo .env, trabalhar com variáveis de ambiente, ou até mesmo aqueles arquivos tomo, aqueles arquivos .ini, arquivos .xml, não interessa. Quando você organiza o seu sistema e toda a parte de configuração dele trabalhando dessa forma, significa que você consegue mudar o comportamento da sua aplicação com suas configurações, conforme o ambiente que você quer fazer o deploy. Backing services. Todos os serviços vão ser tratados como recursos que você vai atachar. A gente já vai falar um pouco mais sobre esses caras aqui. Outro ponto, build, release e run, ou seja, você vai poder fazer o build da sua aplicação, você já vai poder fazer o deploy e rodar a sua aplicação. No final do dia ele vai estar falando em você rodar uma esteira de CI/CD e botar tudo para rodar. Se você consegue fazer isso, você vai ter boas práticas de trabalhar com software. Processos. E aqui que é um ponto importante, lembra que eu falei trabalhar sem estado? Então, é aqui que ele está falando em relação a trabalhar stateless,  ou seja, tudo que você trabalha, não armazene estado na máquina que você está utilizando. Outro ponto, você pode também escolher qual é a porta a qual o seu software vai estar respondendo. Isso é muito comum hoje em dia. Você consegue escalar através de processos que você for rodar. Dispostability, o que ele faz aqui para você? Você tem maneiras de conseguir dar um shutdown na sua aplicação e mantendo a cada momento sua aplicação no ar, mas por exemplo, imagina você tem três máquinas, você quer se livrar de uma porque não tem mais demanda. Então, você vai destruir aquela máquina, mas você vai destruir essa máquina como? De forma graceful. Isso a gente chama de graceful shutdown, ou seja, ele para de receber novas requisições, termina as requisições que ele está processando para depois matar a máquina em si. O que é criar os ambientes de desenvolvimento e produção e manter o ambiente de desenvolvimento e produção mais próximo um dos outros? Os logs têm que ser tratados como event streams, ou seja, log no final das contas são sempre eventos. E esses eventos que acontecem são fluxos contínuos de informação e esses fluxos contínuos de informação não podem ficar gravado nessa máquina porque se ela for “matada” você vai perder os logs. E aqui, admin processes, que é rodar barra administrar ou gerenciar as tarefas como one of process, ou seja, você tem que conseguir executar tarefas específicas na hora que você for subir. Por exemplo, na hora que você quer, por exemplo, fazer um processamento de nota fiscal, você tem que ter a capacidade de subir um ambiente ou subir uma máquina, rodar aquele processo e depois ela pode cair.

Eu recomendo que você leia e entenda a fundo cada ponto desse cara aqui. Então, se você clicar ele vai te explicar, olha, o que é backing services aqui, por exemplo. Backing services é qualquer serviço que a sua aplicação vai consumir através da rede e daqui ele dá exemplos como banco de dados e etc. Então, eu posso ter que querer trocar esses backing services, ou seja, criar uma abstração, ou seja, você vai utilizar métricas, você vai trabalhar com observabilidade, qualquer coisa que a sua aplicação se conecta através da rede é chamado de backing services. Então, você tem que conseguir criar distinções na hora que você for rodar um banco de dados de desenvolvimento. Um banco de dados de produção, como você vai guardar essas credenciais e, assim, uma coisa começa a se correlacionar com a outra.

Então isso aqui é super importante. Eu super recomendo que leia todos os fatores. Não sei se você já tinha ouvido falar, talvez sim, talvez não, mas eu quero que você refresque a sua mente porque esses tipos de coisa vão te ajudar a escalar tantos monólitos como microsserviços. Então, é uma prescrição você entender esses 12 factors. Esses 12 fatores para suas aplicações. Então, vamos continuar.