Bom, pessoal, e agora a gente vai falar um pouco sobre autenticação e autorização em microsserviços. Eu não sei se em algum momento você já tinha pensado em como tudo isso funciona, mas o grande ponto é que quando você trabalha com microsserviços, não necessariamente você vai precisar fazer a autenticação de cada microsserviço, eu estou dizendo isso porque, dependendo da situação, do contexto que você está, o seu microsserviço já vai receber autenticação, quer dizer, a requisição já autenticada, então, isso vai te poupar trabalho para que você faça apenas o serviço que você precisa e não fique necessariamente dependendo de processos de autenticação. Mas aqui existem todas as ressalvas e eu quero explicar aqui para você, baseado nessa imagem aqui que eu criei.

Então, vamos lá, a primeira coisa que a gente tem que pensar é que um usuário vai sempre tentar mandar uma requisição e eventualmente aquela área, naquela rota que ele está acessando vai precisar o que no final do dia? Se autenticar. Então, o que pode acontecer nessa situação? Normalmente, quando você tem diversos sistemas, você não vai querer desenvolver um sistema de login para cada microsserviço, então, o que você vai fazer vai ser o seguinte, o usuário vai bater numa requisição aqui, e essa requisição de autenticação vai acessar aqui diretamente um servidor de autenticação, um servidor de identidade. Esse servidor de identidade vai verificar se as credenciais estão corretas. E caso as credenciais estejam corretas, ele vai retornar aqui para o usuário um token, um  access token e também um ID token. Eu não quero entrar em detalhes sobre OpenID Connect, OAuth2 e etc. Mas de qualquer forma esse token, esse access token vai ser basicamente a chave que o usuário vai utilizar para fazer a próxima requisição. Então, a primeira requisição que ele vai fazer vai ser para se autenticar e conseguir ali um access token e também um ID token. O ID token, em cima do OpenID Connect, o que ele vai fazer normalmente? Ele vai dar inclusive as informações sobre o usuário. Não sobre o que necessariamente ele pode acessar. Hoje em dia, é muito comum esse token ter o formato ali JWT, que é JSON Web Tokens. Ou JWT, em inglês, como o pessoal fala. Ele, com esse token na mão, esse token ele consegue carregar quais são as informações do usuário e quais são roles, por exemplo, ou outras informações que você quer carregar ali no payload desse token.

Agora, o que acontece é o seguinte: nas próximas requisições que o usuário fizer, ele vai passar  o JWT, mas nesse ponto é que está a grande “sacada”, porque a gente tem algumas situações aqui e é isso que eu quero que você preste atenção. A primeira situação é que ele passa o JWT, vai bater na API Gateway, a API Gateway manda o cara para o servidor de identidade, o servidor de identidade verifica se esse token é válido e fala se está válido. Se for válida a autenticação, o processo de acesso… ele acessa diretamente os microsserviços.

Agora, perceba uma coisa aqui. Esses microsserviços não estão verificando a autenticação em nenhum momento, porque a autenticação aqui já passou pelo API Gateway. E o API Gateway tratou dessa intermediação com o servidor de identidade aqui para gente. Então, os usuários finais não precisam necessariamente fazer a autenticação. Essa é a situação número um. Toda vez que o usuário passa o token, bate no servidor de autenticação, estando “ok”, ele continua as requisições para os outros microsserviços. Agora, essa abordagem tem um problema extremamente grave, que é o seguinte: a cada requisição que o usuário faz, toda requisição, de qualquer forma, vai bater no servidor de autenticação. Então, isso torna o servidor de autenticação um ponto único de falha, faz com que o servidor de autenticação esteja sempre sobrecarregado. Então, isso aqui para gente é um baita problema. É um problemão. Como a gente consegue minimizar esses riscos aqui? Nesse caso, o servidor de autenticação consegue emitir novos tokens, porque ele tem uma chave privada, somente dele aqui. Mas, para verificar se um token é válido ou não, basta ele prover para a gente uma chave pública. Com essa chave pública, a gente consegue verificar se o token do usuário foi realmente emitido pelo nosso servidor de autenticação, e se ele foi, a gente pode confiar nesse token. Então, o que a gente pode fazer aqui, nesse caso, é o seguinte, pegar a chave pública desse token, e deixar ela disponível aqui no API Gateway.

Então, toda vez que o usuário mandar uma requisição para qualquer microsserviço, ele vai mandar o token aqui, o JWT, o J aqui, e quando ele mandar, a API Gateway apenas vai verificar se esse token é válido. Se esse token realmente foi emitido pelo servidor de autenticação, porque agora ela tem uma chave pública, e essa chave pública consegue validar se esse token é real ou não. Isso aqui sendo real, ele já encaminha as requisições para os microsserviços para dentro da aplicação. Então, esse aqui é o nosso primeiro ponto que você tem que sacar como uma autenticação e autorização, eu coloco também, porque em relação à autorização, você vai ter as roles que esse cara pode realizar, e baseado nisso, cada microsserviço pode tratar diferente. Mas o nosso primeiro ponto aqui é que o usuário vai poder passar o token, a API Gateway valida se esse token é válido através de uma chave pública, e encaminha, normalmente, a requisição para os microsserviços. No próximo vídeo, eu quero falar um pouco sobre os efeitos colaterais que essa abordagem traz pra gente. Ela traz benefícios, porque a gente não precisa acessar o servidor de autenticação toda hora, porque quem faz a validação da chave é o API Gateway, mas a gente também tem efeitos colaterais. A gente vai falar disso agora.