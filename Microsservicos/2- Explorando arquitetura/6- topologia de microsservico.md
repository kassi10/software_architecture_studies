Bom, pessoal, é o seguinte, no vídeo anterior a gente falou sobre coreografia de microsserviços e a gente falou sobre livre comunicação, demos exemplos da Amazon, da Netflix. Agora, a questão é a seguinte, esse problema de coreografia é um problema muito claro, e normalmente quando você começa a criar bastante microsserviços, esse formato de comunicação vai começar a acontecer invariavelmente. O que você pode fazer para facilitar a vida, para melhorar a gestão desses microsserviços? É você começar a trabalhar com algo que hoje a gente chama de topologia de microsserviços. Esse aqui eu quero desenhar junto contigo (vou colocar aqui, topologia de microsserviços).

O que eu estou querendo dizer com isso? (Eu vou copiar esse cara aqui que a gente tem, vou colar aqui embaixo, mas eu vou diminuir essa imagem). Quando a gente está trabalhando com microsserviços, a gente vai ter essas chamadas aqui. O grande problema que acontece é que a gente começa muitas vezes a fazer isso aqui: o nosso sistema começa a crescer tanto, que a gente começa a ter um encadeamento muito grande de microsserviços, e, assim, essas chamadas começam a ficar muito fortes, porque esse começa a chamar esse, que chama esse, que chama esse, que chama esse, que chama esse. E, com isso, a gente começa a ter esses tipos de problemas. Como você minimiza esses tipos de problema? Eu acho que a dica de ouro que eu posso passar aqui para você, e que se você já trabalha com microsserviços hoje, raramente você vê isso dentro da rede das empresas, então, essa pode ser uma dica de ouro, um game changer para você, que é o seguinte: a gente sabe que microsserviços são softwares comuns que têm um contexto muito bem definido, e esses caras rodam de forma autônoma e se comunicam ali entre si. O grande ponto é que quando você está olhando diversos microsserviços se comunicando, você vai perceber que dentro de um ecossistema, de uma empresa, eles vão fazer parte ainda de um contexto maior, de um subdomínio maior, e quando você entende isso a sua mente vai explodir.

Vamos imaginar que esses microsserviços aqui são responsáveis por fazer todo o faturamento da empresa. Esses microsserviços aqui, são os microsserviços para fazer toda a parte de entrega e logística aqui da empresa. Esse aqui é feito somente para listar o catálogo de busca e mostrar os produtos. E esses aqui são para ajudar na relação com o cliente. Você concorda comigo que apesar desses caras terem funções pequenas e específicas, eles acabam fazendo parte dentro de um contexto maior? Eu sei que aqui você tem um contexto, aqui você tem um outro, mas quando você olha de forma geral, esses caras têm um contexto maior. Então o que você vai poder fazer nesse caso? Você vai poder fazer o seguinte: você vai chegar aqui e você vai delimitar um contexto ainda maior, onde ele fecha um quadrado nos seus microsserviços. Então aqui eu tinha falado para vocês que a área de cobrança, por exemplo, não está aqui, um contexto de cobrança. Aqui a gente tem um contexto de entrega, de logística. Aqui eu tenho um contexto de logística ( logística com J é ótimo), aqui eu tenho um contexto de atendimento ao cliente e aqui eu tenho um outro contexto aqui também, deu para vocês pegarem. O que acontece quando a gente tem esse tipo de situação, quando a gente consegue fazer esse mapeamento desses contextos maiores? A gente vai perceber que esses microsserviços vão querer falar entre si, porque quando acontece uma cobrança, emite uma ordem aqui para a logística fazer entrega, adiciona o cara no CRM, manda o cara aqui mudar o estoque e coisas desse tipo, então esses contextos se falam.

Agora qual é o problema desses contextos se falarem? São as chamadas diretas de um microsserviço para o outro. Estou dando um exemplo, esse falar com esse, que fala com esse, que fala com esse, que fala com esse e assim vai. A coisa aqui começa a ficar complexa, porque além de ter a comunicação dentro dos contextos, você vai ter as comunicações entre os contextos, e você começa a fazer chamadas nesse caso. Como você pode resolver esse tipo de situação? Na realidade a situação não tem resolução, mas ela tem uma forma de minimizar. Você vai criar aqui na frente uma API Gateway (e agora ficou difícil de eu conseguir diminuir a fonte).

Você vai criar aqui na frente uma API Gateway. O que a API Gateway vai fazer? Essa API Gateway vai agrupar esses microsserviços, então, aqui eu vou fazer exatamente a mesma coisa, vou criar esse agrupamento. Aqui eu vou fazer a mesma coisa criando um outro agrupamento. E aqui eu vou fazer a mesma coisa criando um outro agrupamento. Por que isso aqui acontece? (Só estou tentando entender por que esse espaço está maior que o outro, deixa eu só liberar um espaço maior aqui para não ficar um negócio… para ficar mais fácil para explicar). Por que eu tenho esses agrupamentos? Porque a partir de agora, todas as vezes que um microsserviço precisa chamar um outro microsserviço de um outro contexto, isso não vai acontecer mais, não vai acontecer, não vai mais existir a chamada direta. O que vai existir vai ser isso aqui: esse cara precisa chamar o cara de cobrança. Ele vai fazer assim, ele vai chamar o API Gateway aqui. Esse cara precisa mandar os dados para o cliente, “opa espera um pouquinho”, ele vai chamar aqui, esse cara precisa fazer uma chamada para cá, ele vai chamar esse cara aqui, entende o que eu estou dizendo? Então, o nosso grande passo agora é que quando nós conseguimos agrupar esses microsserviços através de uma API Gateway que protege contextos, a coisa vai ficar um pouco mais fácil. No próximo vídeo, eu vou falar sobre os benefícios para a gente fazer isso aqui. Então, vamos nessa!


Parte 2

Bom, pessoal, no vídeo anterior, a gente estava falando sobre essas chamadas e API Gateway na frente de um conjunto de microsserviços dentro de uma rede. Então, isso aqui é um ponto interessante. Isso aqui a gente está vendo que está dentro de uma rede maior. Eu vou até colocar aqui somente para não restar dúvidas aqui do lado de vocês. (Deixa eu colocar esse cara aqui, vou tirar aqui e eu vou colocar que isso aqui está dentro de uma rede maior). 

Olha só que interessante algumas vantagens que a gente tem de trabalhar assim. Os times que estão desenvolvendo esses microsserviços, quando precisam se comunicar aqui, primeira coisa, eles não precisam saber, então vou colocar aqui do lado, “times não precisam saber com qual microsserviço eles vão se comunicar”. (Deixa eu aumentar um pouco a fonte aqui, somente para deixar um pouco mais claro). Eles vão chamar uma API Gateway em um determinado endereço e vão ter esse resultado. Então, isso é um ponto importante. Quais são os benefícios disso? As equipes em outros contextos poderão mudar, refazer, sei lá, reconstruir, trocar a linguagem de programação e ainda  vão conseguir manter o mesmo endereço, o mesmo endpoint, eventualmente, sei lá, o mesmo IP, o mesmo IP ele não vai garantir, porém, você garante o mesmo endpoint. Então, aqui nesse caso, o que vai acontecer, você mantém o mesmo endpoint, tudo isso de forma transparente para quem utiliza o microsserviço. Esse microsserviço precisa emitir uma ordem de cobrança. Vamos imaginar que esse microsserviço aqui é o cara que emite a ordem. Esse microsserviço aqui não precisa saber que é esse cara que emite a ordem. Ele sabe o que precisa saber, que quando ele acessar a barra cobrança, eu vou chamar aqui de, sei lá, charge ou bill,. Quando ele chamar esse cara, esse /bill vai bater nesse cara aqui. Se amanhã eu mudar esse sistema, se eu mudar o endpoint, se eu mudar todas as regras, não interessa, esse cara vai continuar chamando bill. E esse cara aqui nem vai saber que houve uma mudança radical nesse microsserviço. Esse cara aqui não precisa saber que o endereço desse microsserviço mudou. Esse cara aqui não precisa saber que você está realizando um teste AB, porque ele só enxerga a API Gateway aqui.

E também, aqui nesse caso, você começa a ter diversos recursos muito interessantes. Políticas de retry, mais partes de segurança, você vai ter rate limit. Tudo isso pré-configurado no seu API Gateway, e de graça, então o seu microsserviço aqui não vai precisar se preocupar com essas coisas, porque o API Gateway está na frente para fazer isso. Então, ao invés de você ter um cenário maluco, como isso aqui, elevado à quantidade de contextos, você pode ter apenas chamadas diretas para API Gateway, e aqui no meio, cada contexto se vira, cada agrupamento de squads acabam se virando. Então isso muda o jogo muda o jogo totalmente.

Porém, contudo, todavia, entretanto, a minha maior dica também em relação a isso aqui é o seguinte, deixe as APIs Gateways de forma stateless. E o porquê que eu estou dizendo isso? Porque se elas ficarem stateless, você pode matar e subir elas novamente a hora que você quiser. Quando você criar um novo contexto, basta você subir uma nova API Gateway dentro desse contexto que tudo vai está funcionando também. Então, deixe a API Gateway de forma stateless. Se você olhar, por exemplo, eu vou dar alguns exemplos simples aqui de API Gateways OpenSource que você pode utilizar, que você consegue trabalhar de forma stateless. O Kong você consegue trabalhar, e você também consegue, por exemplo, trabalhar com a KrakenD. Obviamente, existem “N” outras soluções para você fazer isso, mas basta deixar essas API Gateways como stateless e você não vai ter problema. Você trabalha com arquivo declarativo, subiu, ela não precisa ter banco de dados, inclusive, para rodar. Ela roda somente nas configurações, logo ela consegue rodar com uma performance muito melhor para ela não ficar trabalhando e tendo acesso a dados. Então, eu acho que nesse ponto está uma mudança de jogo bem grande na hora que você vai montar uma arquitetura baseada em microsserviços.

É isso. (Deixa eu ver se eu tenho mais alguma coisa que eu queria colocar aqui para você). Um ponto importante também na hora que você for fazer isso, é que você tem que preparar o seu time, obviamente, para fazer com que eles não consigam mais fazer essas chamadas diretas. Então, aqui, provavelmente, você vai ter uma Network Policy proibindo chamadas diretas em microsserviços de contextos diferentes, porque se você não fizer isso, vai ter sempre um desenvolvedor que vai querer fazer uma chamadinha direta e, assim, toda essa estratégia de API Gateway vai por água abaixo. Então tome cuidado com isso, crie uma Network Policy para evitar essas chamadas nesses contextos.

Era isso que eu queria passar para vocês sobre esse tipo de topologia. Lembrando que isso aqui pode ser chamado de uma espécie de mini API Gateway aqui. Então, era isso que eu queria trazer. Um grande abraço para vocês e até o nosso próximo vídeo.