Bom, pessoal, agora que a gente conseguiu ver um pouco mais sobre comunicação assíncrona na prática, eu quero mostrar para vocês duas abordagens que normalmente você pode trabalhar com tecnologias diferentes para utilizar a comunicação assíncrona. Uma forma é utilizar mecanismos que trabalham com PubSub, ou Published Subscriber, é um padrão. Como  isso funciona? Você vai ter o sistema que vai produzir a mensagem, e o que vai acontecer? Essa mensagem vai ficar guardada aqui em um tópico, normalmente a gente chama isso de tópico, dependendo do sistema pode chamar isso de fila, o nome que você quiser, o ponto é que ele vai ter um local onde essas mensagens vão ser enviadas. E assim você vai ter o quê? Você vai ter sistemas pendurados neste tópico, aguardando as mensagens chegarem. Conforme as mensagens forem chegando, esses sistemas vão lendo essas mensagens.

Então, isso é muito, mas muito importante para você entender como funciona. Esse é um padrão muito utilizado, e você tem sistemas como o Apache Kafka, Apache Pulsar, você tem o AWS Kinesis, o Google PubSub, etc. que conseguem trabalhar dessa forma para vocês. Nós temos também uma outra abordagem, que você consegue trabalhar de forma assíncrona, mas ele não utiliza esse padrão PubSub, que é no caso aqui, por exemplo, do RabbitMQ, que é um sistema muito interessante de mensageria. E o RabbitMQ, o que faz? Ele faz com que você tenha um pouco mais de flexibilidade na hora de consumir os dados. Por quê? Porque você, na hora que manda uma mensagem, você não manda uma mensagem diretamente para uma fila. Você manda uma mensagem para uma exchange. O que uma exchange faz? Essa exchange, tem regras de distribuição dessas mensagens. Vamos imaginar o seguinte: eu tenho a fila 1, a fila 2 e a fila 3, e o que eu estou fazendo? Eu atrelei essa minha fila a essa exchange, está vendo? O que pode acontecer? O publicador 1 manda uma mensagem para uma exchange, de acordo com a regra da exchange, ela sabe que tem que mandar essa mesma mensagem que foi enviada para 1, para uma fila 1, para a fila 2 e para a fila 3. E assim eu tenho esses consumidores lendo as mensagens dessa fila. Um ponto importante aqui é que assim que esses caras lêem essas mensagens, essas mensagens são apagadas da fila. Abordagens como um Apache Kafka. Quando essa mensagem é lida de um tópico, essa mensagem ainda fica guardada nesse tópico e caso você queira ler novamente a mensagem deste tópico, você pode ler. E você escolhe por quanto tempo essa mensagem fica neste tópico. Se você for trabalhar com o RabbitMQ, utilizando as filas tradicionais dele aqui, você vai perceber que se esse cara lê essa mensagem uma vez. Essa mensagem é dropada, ou seja, ela é removida da fila e se você precisar ler novamente, você não vai conseguir. Existe um outro tipo de fila no RabbitMQ que se assemelha a esse cara, que é o tipo String. O String de dados mantém as mensagens guardadas na fila para você poder fazer a releitura dessas mensagens. Então, isso é importante você saber, a principal diferença aqui é que você não utiliza o padrão PubSub, você vai ter um consumidor por fila. E a Exchange vai fazer o encaminhamento. Poderia ser aqui, por exemplo, algo desse tipo, vamos imaginar que esse consumidor 1, esse publicador 1 manda uma mensagem para a Exchange e essa mensagem é enviada para a fila 2 e para a fila 3. 

Vamos imaginar agora que eu tenho um outro publicador. E esse publicador manda a mensagem para cá. E a Exchange percebe que essa mensagem tem que ser roteada para a fila 1. Então, o que vai acontecer aqui? Tudo que o publicador 2 está mandando vai ser lido, vai ser enviado para a fila 1, onde o consumidor 2 consegue ler. Tudo que o publicador 1 está mandando para a Exchange, a Exchange está mandando para a fila 2 e 3 e somente esses dois consumidores vão ler. Então, pode ser que alguma coisa desse tipo aconteça. Ou ainda eu poderia ter, sei lá, um terceiro publicador, que ele manda uma mensagem para a nossa Exchange, deixa eu mudar a cor aqui. Essa Exchange tem uma regra e ela percebe que tem que mandar a mensagem tanto para a fila 1 quanto para a fila 3. Olha só que interessante. A Exchange tem as regras e depois essas regras são baseadas em algumas keys que a gente chama, e que são enviadas nas mensagens e de acordo com a regra da Exchange, ela direciona para qual fila essas mensagens vão ter. Perceba que esses caras estão publicando as mensagens na mesma Exchange, mas baseado nas regras que essas mensagens são enviadas, a Exchange sabe para quais filas ela tem que encaminhar. Aqui vai para a fila 2 e 3. Aqui vai para a fila 1. E aqui vai para a fila 1 e 2. 1 e 3 quer dizer para você conseguir trabalhar. Isso é importantíssimo para você entender, mas isso aqui é um funcionamento específico do RabbitMQ, você vai perceber que de forma geral um dos pontos assim muito utilizados é a utilização aqui de PubSub. Então, basicamente é isso que eu queria passar nessa aula, nesse nosso vídeo, e a gente segue ali para falar um pouco agora de Event Driven Architecture. Vamos nessa então!