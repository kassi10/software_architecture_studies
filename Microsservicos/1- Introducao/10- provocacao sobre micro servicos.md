Bom, pessoal, no vídeo anterior eu falei aqui para vocês quando a gente pode optar para trabalhar com microsserviços e eu acho que deu para deixar claro que para trabalhar com microsserviços você precisa de grandes desenvolvedores, necessidades de escala diferentes, resolver problemas com arquiteturas e sistemas diferentes, tudo isso é importante.

Porém, o que acontece? Todas as vezes que você for trabalhar com microsserviços eu quero te provocar sobre algumas tecnologias ou pontos importantes que você tem que levar em consideração, que a sua equipe, que o seu time deve saber. Se o seu time não souber esses tipos de coisa, provavelmente eu prefiro sofrer um pouco com monolito com muita gente trabalhando do que fazer isso e virar o caos com microsserviços.

(Então, vamos colar aqui alguns pontos importantes como provocação para você trabalhar ali com microsserviços).

Então, vamos lá, provocação. O mínimo para trabalhar com microsserviços. Primeira coisa, o seu time tem que ter maturidade para trabalhar com pipelines de organização, de pipelines de CI/CD, container registry… Hoje em dia, você tem que entender de containers. Você tem que entender muito bem de arquitetura de software, apesar de que arquitetura de software para criar monolitos também é importante, mas quando a gente está indo para microsserviços você tem que conhecer ainda mais. Você tem que ter uma ótima base de arquitetura de soluções porque você não vai está mais preso a apenas um código, você vai está preso a um ecossistema e, para isso, entender de arquitetura de solução é importante. Você vai ter que entender muito, mas muito bem sobre comunicação assíncrona, ou seja, não é mais aquela chamada direta REST que você vai fazer em outros microsserviços, você vai poder até fazer, mas cada vez que você faz uma chamada direta você gera um acoplamento e fica mais complexo ainda de você ter resiliência nos seus sistemas. Para trabalhar com comunicação assíncrona você tem que entender de message brokers, sistemas de stream de dados e eu estou falando de Apache Kafka, RabbitMQ, ActiveMQ, a gente está falando de SQS, PubSub, a gente está falando de SNS… tem diversos message brokers.

Outra coisa importantíssima, apesar de a gente também pode ter isso em monolítos, mas com microsserviços você eleva isso a décima potência, é trabalhar com concorrência. Você muitas vezes tem microsserviços concorrendo pelos principais serviços que você vai trabalhar. Imagina que você tem um sistema de tickets que várias pessoas vão querer comprar, como eu consigo garantir que ninguém vai comprar o último ticket mais de uma vez? Como eu consigo alugar um quarto de hotel? Como eu consigo fazer buscas em diversos hotéis para trazer o preço mais barato? Como eu consigo evitar que eu tenha uma grande concorrência ali no meu banco de dados? E junto com tudo isso você vai ter que entender um pouco mais sobre mutex, sobre mutual exclusion. Você vai ter que entender mais sobre race conditions, você vai ter que entender como você trabalha com locks pessimista, locks otimistas, lock distribuído, isso é um dos pontos mais importantes, porque até então concorrência, até mesmo sistemas monolíticos tem. Mas trabalhar com lock distribuído você precisa quando você está num ambiente distribuído. Você vai ter que aprender a trabalhar com cache distribuído, e a gente tem os mais diversos tipos de cache.

Outra coisa, você vai ter que ter um banco de dados para cada microsserviço, porque se o seu microsserviço precisa ser autônomo, ele precisa ser independente. Outro microserviço não vai poder ter acesso a esse banco de dados e degradar esse seu serviço. Então, outros microsserviços só vão ter acesso aos seus dados através do microsserviço e não mais diretamente através do banco de dados, porém, nesse momento você começa a ter outras dificuldades que com sistemas monolíticos você não vai ter. Por exemplo, como eu faço relatórios? Se eu tenho diversos bancos de dados e cada pedaço dos dados que eu tenho estão cada um em um microsserviço diferente, como eu gero relatórios? Eu gero um microsserviço para relatório ou eu trabalho com event sourcing. Eu trabalho com flat tables para eles irem preenchendo os relatórios conforme os eventos vão chegando? Então, são várias nuances que você vai ter que entender. Cada vez mais você vai ter que entender mais sobre Domain Driven Design, não somente para você criar código, mas para você entender escopos, para você falar mesmo a língua daquele escopo.

Por último aqui, a gente tem a parte de observabilidade. Logs. Trabalhar com log todo mundo fala que é fácil, “ah, eu boto o log lá no SD-OUT, boto ali um New Relic, um Datadog, um Dynatrace, não interessa qual é o cara que eu vou utilizar e depois eu acesso os logs”. Mas quando você trabalha com microsserviços, os seus logs precisam estar totalmente padronizados para você conseguir fazer buscas e cruzamento de logs entre microsserviços do seu sistema de observabilidade. Então, padronização de logs é algo extremamente complexo e é muito difícil você entrar num consenso, principalmente quando você tem uma arquitetura baseada em microsserviços com um monte de microsserviços funcionando.

Métricas, mesma coisa. Você vai ter que ter métricas daquele microsserviço em específico, porém essas métricas podem também ser necessárias para outros microsserviços. E, baseado nessas métricas, você pode querer pegar anomalias. Hoje em dia, os sistemas de observabilidade têm gerenciamento ou apontamentos de anomalias e para fazer isso de forma cruzada é um pouco mais complexo.

E,por último, mas não menos importante, é a parte de tracing. Quando você tem um problema, você tem o seu stack trace dentro do seu sistema monolítico e você consegue ir debugando. Agora, e se o seu sistema começa a dar problema e você não sabe onde ele deu problema? E se você descobriu onde que ele deu problema, deu problema em um outro microsserviço que não é você que desenvolveu, você vai ter que falar com outra equipe e para isso você precisa de tracing distribuído. Você tem que passar um contexto ou um ID entre microsserviços para você conseguir identificar a request, isso a gente chama normalmente de Correlation ID. Então, isso aqui é um monte de buzzword que eu passei aqui, mas é uma buzzword importante para você ter noção da complexidade que é trabalhar com microsserviços. Agora, não é, porque existe esse grau de complexidade que é algo impossível de saber e que é algo que você tem que saber tudo de uma vez, mas é importante você saber para você começar a estruturar seu ambiente. É aquela história do piloto de avião, você tem milhares de botões ali que o piloto tem que saber apertar, para o avião decolar, para ele apertar e tudo mais. Mas o que acontece? Ele não precisa utilizar todos aqueles botões ao mesmo tempo, é a mesma coisa que acontece com microsserviços, você não precisa saber tudo isso ao mesmo tempo. Entende o que eu estou dizendo? Mas você vai precisar saber, é essa a mentalidade que eu quero trazer para você, você vai ter que saber essas paradas, não tudo ao mesmo tempo, nem sempre você vai usar tudo ao mesmo tempo também, mas é importante, porque a partir de agora, você vai ter um roadmap para você estudar, para você aprender mais. Para quando você começar a trabalhar com seus microsserviços, ou se você já trabalha com seus microsserviços, você já vai ter um grau maior de maturidade e não vai sair falando de “boca cheia” que trabalha com microsserviços. Você vai falar isso de uma forma muito consciente e entendendo o porquê você está utilizando cada uma das coisas. Então, essa provocação não é para assustar, não é para inibir, é saber que tudo isso é um botão diferente no avião. Você não vai apertar todos de uma vez, mas invariavelmente, em algum momento, você vai ter que apertar eles, e é importante você saber. É isso. Um grande abraço e até o nosso próximo vídeo.